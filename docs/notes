## 1. BLE Address randomisation
Central Address Resolution (CAR) is a feature in Bluetooth Low Energy (BLE) that relates to device privacy and is specifically part of the Generic Access Profile (GAP). It is used to manage private addresses in BLE communications, particularly when dealing with devices that use address randomisation for privacy purposes.

What is Central Address Resolution (CAR)?
In BLE, privacy can be implemented by using random addresses instead of static public addresses. This is primarily done to protect the identity of a device, making it harder for attackers to track a device across multiple sessions or locations.

Central Address Resolution (CAR) is a feature used by central devices (like smartphones or computers) to resolve random addresses back to a specific device. When a device uses a random address (a private address), the central device can store the mapping of the random address to the actual identity of the device (i.e., the device's static public address or an identity address). This way, when the device reconnects later, the central device can recognise it even if it uses a different random address.

When is Central Address Resolution Used?
Privacy in Advertising: BLE devices can use random private addresses to advertise and connect, which prevents third parties from tracking them. The central device needs to be able to resolve these random addresses and associate them with a known identity (e.g., a device name or a static public address) for proper communication.

Device Reconnection: If the device changes its random address between sessions, the central device uses CAR to resolve the random address to the known device identity. This makes it easier for the central to reconnect to the device.

Multiple Connections: When multiple devices with random addresses are involved, CAR ensures the central device can track which random address belongs to which known device.

How Central Address Resolution Works
The central device keeps a list of identity resolving keys (IRKs) that help it resolve the random addresses used by peripheral devices. When a central device receives an advertisement from a peripheral using a random address, it will:

Check the advertisement data for the Identity Resolving Key (IRK) that may have been used by the peripheral.

Use the IRK to resolve the random address back to the known identity of the peripheral.

If the address has been resolved, the central device will proceed to handle the device like any other known device, using the resolved identity address.

Use of CAR in GAP
In the context of GAP, CAR is mainly relevant for advertising and connection management, particularly under the privacy feature of BLE.

The Peripheral Privacy Flag in GAP advertisements indicates whether or not a peripheral device supports privacy features such as random addresses. If privacy is enabled and random addresses are being used, the central device will need to support CAR to establish a connection properly.

Key Characteristics Involved in CAR
Resolvable Private Address (RPA):

This is the random address generated by a BLE peripheral for privacy. It is typically used in the advertisement packets to prevent tracking.

Identity Resolving Key (IRK):

This key is used by the central device to resolve a random address into the device's actual identity. It is stored by the central device to allow for future connections.

Privacy Flag:

The Peripheral Privacy Flag is set by the peripheral device in its advertisement to indicate whether it supports privacy features (like random addresses). When set, it indicates the device is using a random address and expects the central to resolve it.

Resolvable Private Address Matching:

The central device will attempt to match the random address it sees in advertisements to an entry in its list of resolved addresses, which are stored in memory, ensuring it can track devices even with changing random addresses.

Summary of Central Address Resolution (CAR) Role in GAP
CAR allows central devices to resolve random addresses used by peripherals for privacy, helping the central maintain a consistent identity for devices that change their addresses over time.

This feature is important for privacy-sensitive applications where random addressing is used to obscure a device‚Äôs identity from external observers.

In GAP, the Peripheral Privacy Flag signals whether the peripheral is using a random address for privacy, and central devices that support CAR can resolve those addresses and connect with the device as needed.

For your WaterRower S4 emulation project, if your Raspberry Pi is going to use randomised addresses to maintain privacy, you would need to ensure that the central devices connecting to it (like a mobile phone or a fitness app) support Central Address Resolution. This will allow them to recognise your device even if it changes its address between sessions. However, if you're using a static address or you're not concerned about privacy, this feature wouldn't be necessary.



If your primary concern is handling connections from devices like phones, which might use random addresses (such as for privacy reasons), then implementing Central Address Resolution (CAR) on the Raspberry Pi is indeed relevant.

Here‚Äôs what you should consider for your WaterRower S4 emulation project:

1. Handling Random Addresses from Central Devices (e.g., Phones)
Phones and other central devices that support BLE privacy may use random addresses when they advertise, and they do so to prevent tracking. While the Raspberry Pi itself doesn‚Äôt need to protect its own privacy, it must be capable of interacting with these central devices that may be using randomised addresses.

To ensure a stable connection with such devices, the Raspberry Pi (acting as the peripheral) can resolve random addresses to make the connection smoother and more reliable, especially when the central device reconnects later.

2. What the Raspberry Pi Needs to Do
Advertising with the correct flags: The Raspberry Pi, while advertising its BLE services (including the custom WaterRower S4 service), should set the Peripheral Privacy Flag in its advertisements to indicate that it‚Äôs capable of handling privacy features (random addresses). This will signal that it‚Äôs prepared to interact with devices that use random addresses.

Identity Resolution: The Raspberry Pi itself doesn‚Äôt need to worry about using random addresses (unless you want it to for its own privacy), but it must be able to accept incoming connections from devices that do use random addresses. For this to happen, it should support address resolution on the central side. In practice, this means the Raspberry Pi will need to support address resolution in BLE, where the Identity Resolving Key (IRK) used by the central device is stored, allowing the Raspberry Pi to match random addresses to the correct device during future reconnections.

3. Enabling Central Address Resolution on the Raspberry Pi
You will need to ensure that your BLE stack on the Raspberry Pi supports CAR to correctly handle devices that use random addresses. Specifically, the BlueZ stack on the Raspberry Pi should handle privacy management (i.e., resolving random addresses into identities) and be capable of working with IRKs (Identity Resolving Keys).

BlueZ (the default Bluetooth stack on Linux) supports these features, and you can work with it through D-Bus interfaces to manage random address resolution.

4. GAP Advertising Settings for Privacy
If the Raspberry Pi is to appear as a WaterRower S4 to other BLE devices, it needs to advertise using the Generic Access Profile (GAP), and this includes:

Advertising with random addresses (if you're using random addresses for privacy).

Setting the privacy flag in the advertisement packet to indicate that the device supports random addresses and the central device can resolve them.

5. What the Central Devices (Phones) Will Do
On the central device side (like a phone), it will need to have a privacy-enabled Bluetooth stack that supports random addressing and Central Address Resolution (CAR).

In practice, most modern phones support this automatically (especially Android and iOS), and they will handle address resolution for you when reconnecting to devices that use random addresses.

Phone behaviour: When a phone connects to the Raspberry Pi‚Äôs emulated WaterRower S4, it will likely use a random address. The central device will resolve the random address into a consistent identity and use it to communicate. As long as the Raspberry Pi supports CAR and random address resolution, the phone will recognise and reconnect to it as needed.

6. Summary of What to Do on the Raspberry Pi
Enable GAP support for random addresses (advertise with random addresses or static if preferred).

Ensure BlueZ is configured to support address resolution (i.e., handle random addresses from central devices like phones).

Set the Peripheral Privacy Flag in the advertisement to signal to central devices that random addresses are used and need to be resolved.

Ensure that identity resolving keys (IRKs) are properly handled for address resolution.

Example: How to Implement Privacy in BlueZ on the Raspberry Pi
If you are using BlueZ for BLE on the Raspberry Pi, it handles a lot of the address resolution automatically. However, you'll need to make sure the right flags are set for your device‚Äôs advertisements.

Here‚Äôs a very simplified outline of what you might need to configure:

Enable Privacy in BlueZ: You can configure BlueZ to use random addresses and handle privacy correctly.

Advertising with Privacy Flag: Make sure that the Raspberry Pi is advertising with the Privacy Flag in its advertisement packets. This will signal to central devices that it supports privacy and will be able to handle address resolution.

Storing IRKs: If the Raspberry Pi needs to maintain a relationship with previously connected devices, make sure it stores IRKs for those devices. This allows it to resolve the random addresses back to the same identity on subsequent connections.

Example using bluetoothctl for testing:
bash
Copy
Edit
bluetoothctl
power on
agent on
default-agent
scan on
You can then observe advertisements and check if random addresses are being used, and if the Raspberry Pi is correctly handling them.

Final Thoughts
To summarise:

Your Raspberry Pi doesn‚Äôt need to protect its own privacy, but it must be able to handle connections from devices like phones that use random addresses.

You can achieve this by ensuring your Raspberry Pi, when emulating the WaterRower S4, is configured to handle random addresses using Central Address Resolution and advertising with the correct flags for privacy in GAP.

BlueZ on the Raspberry Pi should automatically handle most of this for you, but make sure the correct configuration options for privacy and address resolution are enabled.

## 2. How connected BLE devices subscribe to notifications

üîÑ High-Level Flow:
The Central (e.g. phone or app) subscribes to notifications on the RowerData characteristic. This is a standard GATT procedure.

BlueZ invokes the StartNotify() method of your RowerData class.

Your implementation sets self.notifying = True and calls _update_Waterrower_cb_value().

That method schedules a repeating callback using GLib.timeout_add(200, self.Waterrower_cb), i.e. every 200ms.

Waterrower_cb() is now called on a 200ms interval, as long as self.notifying is True.

üßµ Detailed Chain:
üìçStep 1: Notification subscription
The Bluetooth central sends a Write to the Client Characteristic Configuration Descriptor (CCCD).

That causes BlueZ to call your StartNotify() implementation.

üìçStep 2: StartNotify() runs
python
Copy
Edit
def StartNotify(self):
    logger.debug("Entering RowerData.StartNotify")
    if self.notifying:
        print('Already notifying, nothing to do')
        return

    self.notifying = True
    self._update_Waterrower_cb_value()
‚Üí This sets the flag and triggers the first timer-based update.

üìçStep 3: _update_Waterrower_cb_value() runs
python
Copy
Edit
def _update_Waterrower_cb_value(self):
    logger.debug("Entering RowerData.update_Waterrower_cb_value")
    if not self.notifying:
        return

    GLib.timeout_add(200, self.Waterrower_cb)
‚Üí This sets up a 200ms timer that keeps calling Waterrower_cb() until self.notifying is set to False.

üìçStep 4: Waterrower_cb() is invoked
python
Copy
Edit
def Waterrower_cb(self):
    logger.debug("Entering RowerData.Waterrower_cb")
    Waterrower_byte_values = Convert_Waterrower_raw_to_byte()
    ...
    self.PropertiesChanged(GATT_CHRC_IFACE, { 'Value': value }, [])
‚Üí It reads new data from the rower, compares it with the last sent values, and pushes out a notification only if the data has changed.

‚Üí Then it returns self.notifying, which is important:

üí° Why return self.notifying?
Because GLib.timeout_add will keep calling the callback again as long as the return value is True.

So your logic creates a self-sustaining polling loop that only stops if the client unsubscribes (via StopNotify()).

üîÑ What about stopping?
StopNotify() sets self.notifying = False.
Then _update_Waterrower_cb_value() is called again, but since self.notifying is now false, the callback isn't re-added to the GLib event loop.

‚úÖ Summary
So yes:
‚úÖ Waterrower_cb() is eventually called on a 200ms repeating timer
‚úÖ That loop begins when the client subscribes via StartNotify()
‚úÖ It ends when StopNotify() is called

Note that the phone does not automatically subscribe to notifications on the RowerData characteristic when it connects or pairs.

‚úÖ What does happen when a central (like a phone) connects:
The central discovers services ‚Äî it sends a request to discover what services and characteristics the peripheral (your Raspberry Pi) offers. This is usually automatic.

It sees the RowerData characteristic with the notify property.

But in order to receive notifications, the central must:

Write a specific value (typically 0x01 0x00) to the Client Characteristic Configuration Descriptor (CCCD) of RowerData.

This is a standard part of GATT behaviour.

üîÅ Typical Central Behaviour (e.g. an iOS or Android fitness app):
Upon connecting, it:

Discovers the Fitness Machine Service (0x1826)

Finds the RowerData characteristic (0x2AD1)

Writes to the CCCD to enable notifications on that characteristic

Once that happens, BlueZ will call your StartNotify() method, and your GLib.timeout_add(...) cycle begins.

üîê What about pairing?
Pairing and bonding are optional and independent from notification subscription.

Pairing just means that the devices exchange keys and potentially enable encryption.

Bonding means they store those keys for later re-use.

Notifications still require the CCCD to be explicitly written to, regardless of whether the devices are paired.

‚úÖ Summary

Action	Automatically Happens?
Service discovery	‚úÖ Yes
Characteristic discovery	‚úÖ Yes
Notification subscription	‚ùå No ‚Äî requires CCCD write
StartNotify() triggered	‚ùå Only after subscription
Pairing	‚ùå Optional

## 3. Bluetooth transaction collision during pairing
From the debug logs of nRF, it reports an HCI ERROR DIFF TRANSACTION COLLISION even during successful connections. Here's some background:
The error HCI ERROR DIFF TRANSACTION COLLISION (error code 0x2a) that appears in both logs is related to HCI (Host Controller Interface) transaction collision. This error generally occurs when two or more transactions conflict with each other, which can happen during Bluetooth communication, particularly during pairing and bonding.

Here‚Äôs what might be going on and how to address it:

What causes this error?
This error typically occurs when there are conflicting operations happening simultaneously in the HCI layer. These operations can be:

Pairing and Bonding: If two pairing or bonding procedures are initiated at the same time or within a short timeframe, the HCI layer might struggle to handle both operations and will throw a "transaction collision" error.

Connection Parameter Updates: A connection parameter update request could conflict with an ongoing operation like pairing or service discovery.

Multiple HCI Commands: If multiple HCI commands (like pairing, bonding, connection parameter updates) are being issued without proper sequencing, they can conflict and cause this error.

In your case, the error appears during the connection phase (as seen at 13:21:36.045), suggesting that the Bluetooth stack is trying to process multiple commands simultaneously or in a conflicting sequence.

What can you do to fix it?
Sequence and Timing of Operations:

Ensure that pairing, bonding, and connection parameter updates are properly sequenced. For example, you should avoid initiating a connection parameter update while a pairing process is still ongoing.

You can also introduce a small delay between these operations to avoid timing issues. For example, after a pairing operation, wait for it to complete before initiating a connection parameter update.

Revisiting Pairing Procedures:

If your device advertises with the Just Works model and allows for fast pairing, ensure that you're not accidentally initiating bonding or pairing multiple times in parallel.

Make sure the central device (nRF Connect in this case) doesn't try to initiate a new bonding process while one is already in progress.

Avoiding Redundant HCI Commands:

Make sure you're not sending redundant HCI commands (such as multiple connection parameter updates or pairing requests) within a very short timeframe. If the connection parameters are being updated right after the connection, this might be triggering the collision.

Review Bluetooth Stack and Driver Logs:

Depending on your device and Bluetooth stack (whether it‚Äôs BlueZ, Android Bluetooth stack, or something else), there might be configuration settings that control how the HCI layer handles multiple concurrent transactions. If you‚Äôre able to access the Bluetooth stack logs on your host, you may get more insight into which commands are conflicting.

Testing with Single Operations:

For troubleshooting, you can test each operation (pairing, bonding, connection parameters) in isolation to see if any particular operation triggers the issue. Start by establishing the connection first, then apply each additional step (e.g., update connection parameters) one by one to see if the error persists.

In the context of your setup:
Given that you‚Äôre working with a custom Bluetooth advertisement and are trying to manage the pairing process without MITM, it‚Äôs possible that you're inadvertently triggering overlapping operations that are causing the error. For instance:

If the pairing is happening too quickly after the connection is established, this might be causing the collision.

Similarly, if a connection parameter update is sent before the pairing procedure is fully complete, that could trigger this error.

Conclusion:
The HCI ERROR DIFF TRANSACTION COLLISION occurs when Bluetooth operations clash with each other, typically when pairing, bonding, and connection parameter updates are initiated in parallel. The solution is to carefully manage the sequence and timing of these operations, ensuring they don‚Äôt overlap in a way that causes conflicts. You may want to experiment with delaying certain actions or explicitly sequencing them to avoid triggering the error.

4. Consider static passkey if Bluetooth MITM requirement is too frequent
This post suggests a static passkey
https://devzone.nordicsemi.com/f/nordic-q-a/47273/mitm-set-when-using-justwork-option-how-is-this-possible 
Here's some security considerations though
https://security.stackexchange.com/questions/206333/just-works-bluetooth-low-energy-security

5. JustWorks bluetooth
There are some more further reading links for JustWorks bluetooth here:
https://devzone.nordicsemi.com/f/nordic-q-a/17165/ble-just-works-pairing

6. Apple bluetooth
Consider copying over services/update-bt-cfg files from pirowflo to support Apple bluetooth. This would also require re-enabling the relevant code within install.sh.